%% Copyright © 2014 Pierre Fenoll ‹pierrefenoll@gmail.com›
%% See LICENSE for licensing information.
%% -*- coding: utf-8 -*-
-module(patmat_gen).

%% patmat_gen: 

-export([ ast2erlang/1 ]).


%% API

ast2erlang ({rule, Name, Patterns, Product} = Ast) ->
    IDs = ids(Patterns),
    [ head(Name)
    , defrecord(IDs)
    , defpatterns(Patterns, 1, [])
    , defproduction(Product)
    , "\n%% API\n\n"
    , defast(Ast)
    , defhat()
    , defrule()
    , foot() ].

%% Internals

%% Create a record “c” with lIDs as fields
defrecord (IDs) ->
    Fields = [atom_to_list(ID)++"=''" || ID <- IDs],
    ["-record(c, {", string:join(Fields, ", "), "}).\n\n"].

%% Create Erlang -defines to simplify patterns code
defpatterns ([Pattern|Rest], I, Acc) ->
    Def = [ "-define(P"
          , integer_to_list(I), "(", ids2args(Pattern), "), "
          , patt2erl(Pattern), ").\n" ],
    defpatterns(Rest, I+1, [Def|Acc]);
defpatterns ([], _, Acc) ->
    lists:reverse(Acc).

ids2args (Patt) ->
    string:join(lid(ids([Patt])), ",").

patt2erl ({{id,Lhs}, Info, {id,Rhs}}) ->
    ["{", lid(Lhs), ", ", pp(Info), ", ", lid(Rhs), "}"];
patt2erl ({{id,Lhs}, Info, Rhs}) ->
    ["{", lid(Lhs), ", ", pp(Info), ", ", pp(Rhs), "}"];
patt2erl ({Lhs, Info, {id,Rhs}}) ->
    ["{", pp(Lhs), ", ", pp(Info), ", ", lid(Rhs), "}"];
patt2erl ({Lhs, Info, Rhs}) ->
    ["{", pp(Lhs), ", ", pp(Info), ", ", pp(Rhs), "}"].

%% Erlang -define for the production
defproduction (Product) ->
    ["-define(R(", ids2args(Product), "), ", patt2erl(Product), ").\n"].

%% AST's IDs found in patterns
ids (Patterns) ->
    lists:usort(
      lists:flatmap(
        fun
            ({{id,Lhs}, _, {id,Rhs}}) -> [Lhs, Rhs];
            ({{id,Lhs}, _, _}) -> [Lhs];
            ({_, _, {id,Rhs}}) -> [Rhs];
            ({_, _, _}) -> []
        end, Patterns)).

%% ID as an Erlang variable (literal ID)
lid (IDs)
  when is_list(IDs) ->
    [lid(ID) || ID <- IDs];
lid (ID) ->
    [H|Rest] = atom_to_list(ID),
    [string:to_upper(H) | Rest].

%% Define the ast/0 function
defast (Ast) ->
    io_lib:format("ast () ->\n    ~p.\n\n", [Ast]).

%% Define rule's hat function
defhat () ->
    "r (Parent) ->\n    r(Parent, [], '').\n\n".

%% Define the actual rule ('s combinations)
defrule () ->
    "ok".%% TODO

%% perms ([]) -> [[]];
%% perms (L) ->
%%     [[H|T] || H <- L,
%%               T <- perms(L -- [H])].

pp (Data) ->
    io_lib:format("~p", [Data]).

head (Name) ->
    io_lib:format("%% Code auto-generated by module ~p
%% -*- coding: utf-8 -*-
-module(rule1).
-compile(nowarn_unused_vars).

%% rule: ~p.

-export([ doc/0
        , r/1
        , ast/0 ]).


-define(ignore_anything_else
       , eof -> ok;
         _M  ->
               r(Parent, Seen, Closure)).
\n", [?MODULE, Name]).

foot () ->
    "\n%% End of Module.\n".

%% End of Module.
